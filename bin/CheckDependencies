#!/usr/bin/python

import os
import sys
import os.path
from GuessProgramCase import *
from GetAvailable import *
from GuessLatest import *
from FindPackage import *
from GetInstalled import *
from PythonUtils import *

import re

#########
def Get_Dir(mode,program,version):
   return '/Programs/'+program+'/'+version
#########


## Optimization
s_blank='[ \t]*'
s_name='([A-Za-z0-9][-A-Za-z0-9_+]*)'
s_open='([[(])'
s_close='([])])'
s_version='([0-9a-z._\-]*)'

new_format = s_name+s_blank+s_open+s_blank+s_version+s_blank+','+s_blank+s_version+s_blank+s_close+s_blank
new_format_c = re.compile(new_format)

#old_format = s_name+s_blank+'(.*)'+'(.*)'+s_version+'(.*)'
old_format = s_name+s_blank+s_version
old_format_c = re.compile(old_format)
##

# FIXME
dependenciesServer = "http://gobo.detsch.no-ip.org/dependencies/"
#dependenciesCacheDir = "/tmp/Dependencies/"
dependenciesCacheDir = os.path.expanduser('~/.Settings/dependencies_cache/')

if not os.access(dependenciesCacheDir, os.R_OK) :
	os.makedirs(dependenciesCacheDir)


for i in ['recipe', 'official_package', 'contrib_package', 'local_package'] :
	if not os.access(dependenciesCacheDir+i, os.F_OK) :
		os.makedirs(dependenciesCacheDir+i)

#############################################################################
# Functions used to identify which rules apply to a given program version 
#  type (a specific url can be passed, to avoid calling 'FindpPackage')
#############################################################################

# Notice that type may be required since dependencies(recipe(p)) != dependencies(package(p))
def get_rules_for(p, v, t, u=None) :
	depfile = find_dependencies_file(p, v, t, u)
	if depfile :
		f = open(depfile)
		i=0
		toReturn = []
		for line in f.readlines() :
			i += 1
			rule = interpret_dependency_line(line) # todo: add exception handling
			toReturn.append(rule)
		f.close()
		return toReturn	
	return []


def find_dependencies_file(p, v, t, u=None):
	name = (p+"--"+v).lower()
	
	if t == 'installed' :
		p = GuessProgramCase(p, v)
		localdep = Get_Dir('runtime', p, v)+"/Resources/Dependencies"
		if os.access(localdep, os.R_OK) :
			return localdep
	
	elif t == 'local_package' :
		cachedep = dependenciesCacheDir+'/'+t+'/'+ name
		if os.access(cachedep, os.R_OK) :
			return cachedep
		if not u or os.access(u, os.R_OK) :
			ret = FindPackage(p, v, types=[t], availables=global_available_packages_cache)
			if ret :
				p,v,t,u = ret[0]
		if u :
			if os.path.isdir(u) :
				if os.access(u+'/Resources/Dependencies', os.R_OK) :
					return u+'/Resources/Dependencies'
			else :
				err = os.system('tar xvfj %s -O %s/%s/Resources/Dependencies 2> /dev/null > %s'%(u,p,v,cachedep))
				if err == 0:
					return cachedep
				else :
					os.remove(cachedep)
		
	elif t == 'recipe' :
		# searches local recipes first
		compileRecipeDirs, getRecipeStores = getCompileOptions()
		for compileRecipeDir in compileRecipeDirs :
			if os.access(compileRecipeDir+'/'+p+'/'+v+'/Resources/Dependencies', os.R_OK) :
				return compileRecipeDir+'/'+p+'/'+v+'/Resources/Dependencies'
	
	if t in [ 'official_package', 'contrib_package', 'recipe' ] :
		cachedep = dependenciesCacheDir+'/'+t+'/'+ name
		if os.access(cachedep, os.R_OK) :
			return cachedep
		
		#if url :
		err = os.system('wget -q -O '+cachedep+' '+dependenciesServer+"/"+t+"/"+name.lower())
		if err == 0:
			return cachedep
		else :
			os.remove(cachedep)
	
	#found = FindPackage(program, version, False, False, [t])
	#if found:
	#	output = dependenciesCacheDir+"/"+t+'/' +name.lower()
	#	err = os.system('wget -O '+output+' '+dependenciesServer+"/"+t+"/"+name.lower())
	#	if err == 0:
	#		return output
	print 'Not found :(',p,v
	return None
	  
def interpret_dependency_line(line) :
	line = line.split('#')[0].strip()
	if not line :
		return
	
	m = new_format_c.match(line)
	if m :
		return {'program'    : m.group(1),
				'loincluded' : m.group(2) == '[',
				'lover'      : m.group(3),
				'hiver'      : m.group(4),
				'hiincluded' : m.group(5) == ']'}
	else :
		m = old_format_c.match(line)
		if m :
			return {'program'    : m.group(1),
					'lover'      : m.group(2),
					'loincluded' : True,
					'hiver'      : '',
					'hiincluded' : False}
		else :
			raise Exception("Parse error")

#############################################################################
# Fucntion that interpret the semantic of the rule, 
#  and compares it to a given version
#############################################################################

def does_version_match_rule(version, rule) :
	loOk=True
	hiOk=True
	if rule['lover'] :
		loOk=False
		if rule['loincluded'] or rule['lover'] != version :
			if GuessLatest([version,rule['lover']]) == version :
				loOk=True
	
	if rule['hiver'] :
		hiOk=False
		if rule['hiincluded'] or rule['hiver'] != version :
			if GuessLatest([version,rule['hiver']]) != version :
				hiOk=True
	
	if loOk and hiOk :
		#print 'Version:',version,' does match ',rule
		return True		
	else :
		#print 'Version:',version,' does NOT match ',rule
		return False

#############################################################################
# Functions that try to match the given rule against the installed programs
#  and available packages/recipes
#############################################################################

# TODO: reset this when required
global_available_packages_cache = {}

def find_matching_package(rule, acceptable_types) :
	global global_available_packages_cache
	if not global_available_packages_cache :
		global_available_packages_cache = GetAvailable(types=['installed','local_package','official_package', 'recipe', 'contrib_package'])
		
	available_options = FindPackage(rule['program'], types=acceptable_types, availables=global_available_packages_cache)

	if available_options :
		for program, version, t, site in available_options :
			if does_version_match_rule(version, rule) :
				return (program, version, t, site)
		return ((rule['program'],rule['lover'], None, "NOWHERE! No version!"))
	else :
		return ((rule['program'],rule['lover'], None, "NOWHERE! No program!"))

#############################################################################
# Hi-level Functions
#############################################################################

# Recursivelly identifies the dependencies for a given package / recipe as long as a 'solution' for each one
def get_all_dependencies_and_solutions_for( p, v=None, t=None, url=None,
	                                    acceptable_types=None, mode='missing', recursive=True, hook=None,
	                                    all_matches = None):
	#print "Entering",p,v
	ordered_matches, ordered_rules = [], []
	self_match, self_rule = None, None
	
	if all_matches == None :
		global_available_packages_cache = {}
		all_matches = []
		first_call = True
	else :
		first_call = False
	
	if not acceptable_types :
		acceptable_types = getGoboVariable('defaultRepositories', 'Scripts/FindPackage.conf', True)
	
	if not v or not t :
		if t : 
			ret = FindPackage(p, v, types=[t])
		else : 
			ret = FindPackage(p, v, types=['installed'])
			if not ret :
				ret = FindPackage(p, v)
		
		if not ret :
			return
		
		self_rule = { 'program':p, 'lover':'', 'loincluded':False, 'hiver':'', 'hiincluded':False }
		self_match = ret[0]
		all_matches.append(self_match)
		p,v,t,url = self_match
	
	all_rules = get_rules_for(p, v, t, url)
	# optimization only:
	#all_rules  = [ r for r in all_rules if not any(pp == r['program'] for pp,vv,tt,uu in all_matches) ]	
	
	missing_dependencies = [ r for r in all_rules if not find_matching_package(r, ['installed']) ]	
	
	for rule in all_rules :
		if hook :
			hook("Checking dependencies", len(all_matches), len(all_matches)+1)
			
		if mode == 'missing' and find_matching_package(rule, ['installed'])[2] :
			continue
		
		match = find_matching_package(rule, ['installed']+acceptable_types) # (program, version, type, site)
		if mode == 'updating' and find_matching_package(rule, ['installed']+acceptable_types)[2] == 'installed' :
			continue
		# Note: if no package is found, find_matching_package returns a 
		#       tuple with None in the place of type
		if not match in all_matches :
			all_matches.append(match)
			pp, vv, tt, uu = match
			if tt and recursive :
				rr, mm = get_all_dependencies_and_solutions_for(pp, vv, tt, uu, acceptable_types, mode, recursive, hook=hook, all_matches=all_matches)
				ordered_matches += mm
				ordered_rules += rr
				
			# Using recursion in our favor: appending after recursion returns ensures an 
			#  automatic correct output ordering (which is indeed nice :)
			# Note that this explains why two lists are used (ordered_matches and all_matches:
			#  the later being responsible to avoid infinite recursion on circular dependencies)
			ordered_matches.append(match)
			ordered_rules.append(rule)
	
	if self_match and self_rule:
		rule = self_rule
		ret_type = find_matching_package(rule, ['installed'])[2]
		if not ((mode == 'missing' and ret_type) or (mode == 'updating' and ret_type == 'installed')) :
			ordered_matches.append(self_match)
			ordered_rules.append(self_rule)
	
	if hook and first_call:
		hook("Checking dependencies", len(all_matches), len(all_matches))
			
	return ordered_rules, ordered_matches

#############################################################################
# Extra Functions
#############################################################################
CheckDependencies=get_all_dependencies_and_solutions_for
CheckAllwaysUpdateDependencies=get_all_dependencies_and_solutions_for
	
def ListDependencies(p, v, t, u, mode = 'terminal', types=None, report_missing=False, report_updating=False, recursive=True, hook=None) :
	
	if not types :
		types = getGoboVariable('defaultRepositories', 'Scripts/FindPackage.conf', True)
		
	all_rules, all_solutions = get_all_dependencies_and_solutions_for(p,v,t,u, types, recursive=recursive, hook=hook, mode='all')
	#all_rules = get_rules_for(p,v,t,u)
	
	if report_missing :
		missing_dependencies = [ r for r in all_rules if not find_matching_package(r, ['installed'])[2] ]
		missing_programs = [ r for r in missing_dependencies if 'program' in find_matching_package(r, ['installed'])[3] ]
		unresolvable_dependencies = [ r for r in missing_dependencies if not find_matching_package(r, ['installed']+types)[2] ]
		
	if report_updating :
		updating_dependencies = [ r for r in all_rules if not find_matching_package(r, ['installed']+types)[2] == 'installed' ]
		
	if mode == 'terminal' :
		s = ''
		for r in all_rules :
			ss  = r['program'] + ' ' + (r['loincluded'] and '[' or '(') + r['lover'] + ',' + r['hiver']+ (r['hiincluded'] and ']' or ')')
			if report_missing and r in missing_dependencies :
				ss += ' M' + (r in missing_programs and 'P' or 'V')
			if report_updating and r in updating_dependencies :
				ss += ' U'
			s += ss + '\n'
		return s.strip()
	
	elif mode == 'html' :
		s = '<p><font color="#000077"><b>['+'Dependencies'+'] </b></font><br>'
		for r in all_rules :
			ss=''
			if report_missing and r in missing_dependencies :
				if r in missing_programs :
					ss += '<font color="#FF0000">'
					if r in unresolvable_dependencies : ss += '<b>'					
				else :
					ss += '<font color="#000000">'
			else :
				ss += '<font color="#000000">'
			ss += r['program'] + ' '
			if report_missing and r in missing_dependencies :
				if report_missing and not r in missing_programs :
					ss += '</font><font color="#FF0000">'
					if r in unresolvable_dependencies :	ss += '<b>'					
			elif report_updating and r in updating_dependencies :
				ss += '</font><font color="#0000FF">'
			ss += (r['loincluded'] and '[' or '(') + r['lover'] + ',' + r['hiver'] + (r['hiincluded'] and ']' or ')')
			if r in unresolvable_dependencies : ss += '</b>'			
			s += ss + '</font><br>'+'\n'
		
		if not all_rules : s += '<font color="#000000">-</font><br>'
		return s
	else :
		return rules
	
	pass
	
def does_x_depend_on_y(x, py, acceptable_types=None, all_programs=None) :
	px, vx, tx, ux = x
	if all_programs == None :
		all_programs = []
	
	if px.lower() == py.lower() :
		return True
	
	for rule in get_rules_for(px, vx, tx, ux) :
		p = rule['program']
		if p.lower() == py.lower() :
			return True
		if not p in all_programs :
			all_programs.append(p)
			match = find_matching_package(rule, acceptable_types) # (program, version, type, site)
			pp, vv, tt, uu = match
			if tt :
				x = does_x_depend_on_y((pp, vv, tt, uu), py, acceptable_types, all_programs)
				if x :
					return True
	return False



if __name__ == '__main__' :
	import sys
	import getopt, os

	try :
		if not sys.argv[1:] :
			sys.argv[1:] = [ '--help' ]
		opts, args = getopt.getopt(sys.argv[1:], 't:m:WRh', ['types=', 'type=', 'mode=', 'no-web', 'no-recursive', 'help'])
	except getopt.GetoptError, detail :
		print sys.argv[0].split('/')[-1]+': '+str(detail)
		sys.exit(1)
		
	validTypes = ['installed', 'local_package', 'official_package', 'recipe', 'contrib_package', 'tracked', 'all']
	types =  None
	mode = 'missing'
	typesChanged = False
	recursive = True
	noWeb = False
	
	for o, a in opts :
		if o in ['--types','--type', '-t'] :
			typesChanged = True
			types = a.split(',')
			for i in range(len(types)) :
				if len (types[i]) == 1 :
					for t in validTypes :
						if types[i][0] == t[0] :
							types[i] = t
							break
			if 'all' in types :
				types = validTypes[:-1] # don't include 'all'
		elif o in ['--mode','-m'] :
			mode = a
		elif o in ['--no-recursive','-R'] :
			recursive = False
		elif o in ['--no-web', '-W'] :
			noWeb = True
			if not typesChanged :
				types =  [ 'local_package' ]
		elif o in ['--help', '-h'] :
			print """
CheckDependencies
 Check dependencies. No decent help yet.
 
Options:
 -t [t1,t2,...]
 --types=[t1,t2,...]  Sets what kind of packages can be searched, in the 
                      passed order. Valid types are: 
                       local_package, official_package, contrib_package, 
                       recipe, tracked, all
                      Using only the first character from any of the above 
                      is also valid:
                       l, o, c, r, t, a     
                      Default types are:
                       local_package, official_package
                      Notice that when "recipe" type is used, Compile.conf is 
                      read to set recipe-store locations and local recipes 
                      locations. 
 
 --force-update       Downloads required packages list even if there is a
                      local copy (cached in ~/.Settings/cache/) newer than one hour.

 -m, --mode           Mode => ['all', 'missing', 'updating'] 
 -W, --no-web         Do not try to download anything and don't lists 
                      remote recipes and packages (if not explicitly listed
                      in '--types='). Overrides '--force-update'.

Examples of usage:
 CheckDependencies kde-libs 3.5.0
 CheckDependencies kde-libs 3.5.0 recipe
 CheckDependencies -t official_package,recipe kde-libs 3.5.0 recipe 
 CheckDependencies -t official_package,recipe kde-libs 3.5.0 recipe 
 """
			sys.exit(0)
	
	if len(args) >= 1 : p = args[0]
	else :              sys.exit(1)
	
	if len(args) >= 2 : v = args[1]
	else :              v = None
	
	if len(args) >= 3 : t = args[2]
	else :              t = None
	
	if len(args) >= 4 : u = args[3]
	else :              u = None
	
	if mode == 'list' :
		print ListDependencies(p,v,t,u,recursive=recursive,hook=consoleProgressHook)
	else :
		rr, mm = get_all_dependencies_and_solutions_for(p, v, t, u, types, mode=mode, recursive=recursive, hook=consoleProgressHook)
		if rr :
			for r,m in zip(rr,mm):
				print m
		else :
			sys.exit(1)		


